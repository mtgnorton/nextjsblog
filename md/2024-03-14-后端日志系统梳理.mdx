## 概述
	- 一个可靠的日志系统系统需要满足一些必须的前提条件,如下
		- **日志级别可以动态调整**
		- 使用结构化日志,如json
		- 避免敏感信息
		- **日志需要包含对应位置的有效上下文信息**
		- **对于高频率的输出日志,应该根据时间或数量进行采样**
		- **日志需要注意大小,如果过长应该有全局的截断操作**
		- **根据不同的日志级别产生不同的日志文件**
		- **日志文件需要有滚动策略,避免无限增长**
		- 在不要求极高性能的情况下,打印日志代码位置
- ## 日志级别
	- ### Debug|Trace
		- **记录整个执行路径的详细执行过程**
		- 例如
			- 函数开始时,结束时(包含函数执行时间)
			- 分支判断
			- 具体的sql
			- 后台任务的执行和结束
		- 注意
			- debug 日志应该仅用于测试环境和生产环境下的特定调式,生产环境不能长时间开启
	- ### Info
		- **记录系统的生命周期事件的状态,关键业务流程,重要操作的耗时,统计类的信息,用户输入参数错误导致的正常业务错误**
		- 例如
			- 系统启动,重载时,各模块是否成功启动
			- 跟踪核心流程,如订单支付完成,用户注册成功等
			- 用户下单的耗时
			- 在线用户的数量
			- 用户输入的金额不正确
		- 注意
			- info日志数量不能过于庞大,过于庞大说明日志级别设置不合理
			- 对于业务而言,相对于Debug,Info日志更关注操作的发生,而Debug应该包含操作的具体过程
	- ### Warning
		- **记录潜在问题，系统仍能正常运行但需关注。这种类型的问题无需人工干预**
		- 例如:
			- 某个请求的耗时在一定时间内时为Info日志,否则为Warning日志
			- 某个第三方请求在经过重试后,仍然失败
			- 某个ws连接的接受缓冲区溢出导致数据丢包
	- ### Error
		- **记录某个错误导致部分模块或整个系统彻底不可用,需要人工立即接入**
		- 例如:
			- 数据库无法连接
			- panic
			- 关键业务流程无法完成
			- 外部依赖不可用
		- 注意:
			- error日志应该接入告警
- ## 日志上下文
	- ### 全局信息
		- 为了便于在kibana等日志系统中筛选出特定请求或操作,需要在日志中添加一些全局的上下文信息,这些信息应该在整个调用链路中保持一致
		- RequestID|TaskID
			- 类似于链路ID,在非分布式的系统中,也需要一个唯一ID,标识一系列调用属于同一个请求或操作,在web服务请求中可以用RequestID标识,在后台常驻任务的一个子任务中可以用TaskID标识
		- UserID|Fingerprinting
			- 用户登陆后或未登陆,都应该有一个唯一标识来识别用户,如UserID或Fingerprinting
		- 对象和方法名
			- 对象中的方法在日志中开头加上对象名和方法名,如`order.Process`,函数中的日志开头加上函数名如`Process`
	- ### 局部信息:
		- 附加在日志中的上下变量,应该和该日志直接相关,方便排查问题,但是不能冗余,尤其是在调用链中, 每层调用应该只记录该层直接使用到的变量
- ## 慢操作日志
	- 正常情况下监控耗时的日志一般为Debug或Info,对不同场景设置一个时间阈值,如果超过阈值应该提升为Warning级别
	- 例如:
		- web服务用户请求
		- 第三方依赖请求
		- 后台任务执行时间过长
- ## 动态设置局部Debug日志输出
	- 在生产环境中,有的时候需要临时开启Debug日志来排查问题,但是又不想全部开启,这时候就需要动态设置局部Debug日志输出
	- 例如:
		- 如web请求中携带debug参数或header头,当传递时,开启该请求链路的Debug日志
		- 通过接口或者后台设置开启某个用户或根据未登录时的唯一标识 开启Debug日志
		- 通过接口或者后台设置开启某个模块的Debug日志
			- 需要分模块开启debug日志时,模块考虑使用单独的logger实例