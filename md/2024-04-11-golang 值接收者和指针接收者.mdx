
- ## 使用原则
- 不强制使用某个类型,但需要满足一下原则
    - 只要一个方法使用指针接收者,则所有该类型的其他方法都使用指针接收者
    - 如果需要修改接收者,则使用指针接收者
    - 如果接收者很大,则使用指针接收者
    - 如果接收者很小、不需要修改且不需要处理 nil,可以用值接收者
- ## 接口类型
- 接口实质上在底层用两个字段表示：
    - 一个指向某些特定类型信息的指针。
    - **数据指针**
        - 如果赋给接口的是指针，则数据指针直接存储该指针。
        - 如果赋给接口的是值，则 Go 会分配内存，创建该值的副本，数据指针存储指向该副本的指针。


- ## 值接收者和指针接收者
- ### 方法集
- **值接收者方法 同时属于 T 和 \*T 的方法集, 指针接收者方法 只属于 \*T 的方法集。**
- golang这种规则的原因如下:
    - 当将一个值实例赋给一个interface变量时，interface变量的数据指针存储的指向这个值的副本的指针。如果方法是用指针接收者定义的,那么interface变量调用这个方法时，它操作的将是指向值的副本的指针，而不是指向原始的指针。这通常不是期望的行为，也可能破坏指针接收者的设计意图（比如修改无法作用于原始值）

    ```go
        type F interface {
        f()
        }

        type S1 struct{}

        func (s S1) f() {}

        type S2 struct{}

        func (s *S2) f() {}

        s1Val := S1{}
        s1Ptr := &S1{}
        s2Val := S2{}
        s2Ptr := &S2{}

        var i F
        i = s1Val
        i = s1Ptr
        i = s2Ptr

        //  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器
        //   i = s2Val
    ```
- ### 调用
- 无论是值接收者还是指针接收者,正常情况下,都可以被指针或者值的实例调用,有一个特例需要注意
    - **当值实例无法寻址时,无法调用指针接收者的方法**,原因是go编译器默认会为可寻址的值实例隐式转换成指针,从而调用指针接收者的方法,如果值实例无法寻址,则无法转换,从而无法调用指针接收者的方法
    - 一个值是可寻址的，意味着你可以使用 & 操作符来获取它的内存地址。
    - 示例
        ```go
        type T struct {
            a int
        }
        func (t T) M1() {
            fmt.Println("M1")
        }
        func (t *T) M2() {
            fmt.Println("M2")
        }
        func TestSlice(t *testing.T) {
            T{1}.M1() // 正常
            T{1}.M2() // 无法编译通过
            m := map[string]T{"1": T{1}}
            m["1"].M1() // 正常
            m["1"].M2() // 无法编译通过
        }
        ```

